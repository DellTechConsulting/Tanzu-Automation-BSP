Youtube Link: https://www.youtube.com/watch?v=UVUd9_k9C6A

1. Don't fear the shell.
Commands:
=> Set-Location c:\ [Eq to cd\]
=> Get-Childitem [Eq to dir]
=> Clear-Host [Eq to cls]
=> Get-Alias [List all the alias, and this itself has alias "gal"; also "gal *"]
=> Get-Alias -Definition Get-Process [To find alias for cmdlets. "-Definition" is the parameter.]

2. The help system.
=> Update-Help -Force [To update HELP from the Internet.]
=> Get-Help *service* OR Get-Help g*service* OR Get-Help G*Adcomputer*
=> Get-Help Get-Service
=> Get-Verb [Display's all the verbs.]
=> Get-Verb | Measure [To display the number of verbs available in PowerShell.]
=> Get-Help Get-Service -Detailed
=> Get-Service "wmi*" [Get services that begin with a search string]
=> Get-Service -Displayname "*network*" [Display services that include a search string]
=> Get-Service -Name "win*" -Exclude "WinRM" [Get services that begin with a search string and an exclusion]
=> Get-Help Get-Service -Examples [Would directly display the examples.]
=> Get-Help Get-Service -Full [Similar to -Detailed, but with more info with regards to Parameters and how it works with Pipeline.]
=> Get-Help Get-Service -Online [Takes you to online MS documentation for the cmdlet specified.]
=> Get-Help Get-Service -ShowWindow [Displays FULL details of cmdlet in a separate window.]
=> Parameter & Parameter Sets: ["-" Dash prefix indicates it's a Parameter.]
	** Arguments: Are the values to Parameter.
	** Get-Service -Name b*,c* [Here we used "-Name" parameter which takes multiple arguments from its syntax "<System.String[]>".]
	** Parameters that are itself closed inside "[]" eg: [-ComputerName <System.String[]>], indicates they are optional to be specified while you use those in your commands.
    ** Mandatory: You need to specify the parameter and its value to execute the cmdlet. eg: [-LogName] <String> - Here you see the STRING is not inside the [] that means STRING is mandatory. However as logname is inside [] it's OK if we don't type it. Eg: Get-Service -DisplayName Bit*; Get-EventLog [-LogName]
	** Optional: You can use or you may not, hence not complusory. If both "The Parameter and its Value are in square bracket then it's not mandatory parameter. eg: [-ComputerName <System.String[]>]
	** Positional Parameters: Requires only that you type the arguments in relative order. No need to type the parameter name, just the value in that position is enough. System will map 1st unnamed argument to 1st positional parameter and 2nd unnamed argument to 2nd positional parameter. Eg:- ["[-Name] <String[]>"]. 
	** Named Parameters: When I specify the complete Parameter name then it's called as Named Parameter. Eg: -Name bits, -ComputerName DC1, -LogName System

3. The Pipeline:
	** Get-Service -Name bits | Stop-Service
	** -PassThru: It will display me the result of what I am running.
	** Get-Service -Name bits | Start-Service -PassThru
	** Get-Service | Export-Csv -Path c:\services.csv
	** notepad c:\services.csv
	** Import-Csv c:\services.csv
	** Get-Process | Export-Clixml -Path c:\good.xml
	** Compare-Object -ReferenceObject (import-clixml c:\good.xml) -Difference -Process) -Property name
	** Get-Service | Out-File -FilePath c:\test.txt
	** Get-Content c:\test.txt
	** Get-Service | ConvertTo-html -Property name,status | Out-file c:\test.htm
	** c:\test.htm
	** Get-Service | Stop-Service -whatif [Will not execute anything, but it will tell what would happen if you execute it.]
	** Get-Service | Stop-Service -Confirm [To get CONFIRMATION before it executes.]
	** Get-Service -DisplayName *bi* | Stop-Service -whatif
	** gsv -DisplayName bi*
	
4. Extending the Shell:
	** Get-Module -ListAvailable [Module is like old days GUI SNAP-INs to load specific functionality. This command gets the modules that are installed on the computer and can be imported into the current session.]
	** Get-Module [List the modules imported in the current session or that can be imported from the PSModulePath.]

5. Object for the Admin:
	** Objects and its Properties and Methods.
	** Methods - Used to drive the objects.
	** get-process | where handles -gt 900
	** get-process | where handles -gt 900 | sort handles
	** get-service -name bits | Get-Member ["Get-Member" displays all the related methods to that object.]
	** get-service | Select-Object -Property name,status [Displays only those roperties that are mentioned after -Property parameter.]
	** get-childitem | select -Property name,length | sort -Property length [Sorts the files and folders with its size in acending order.]
	** get-childitem | select -Property name,length | sort -Property length Descending
	** get-EventLog -LogName System -Newest 5 | Select -Property EventId,Timewritten,Message | sort -Property timewritten | ConvertTo-html | Out-File c:\error.htm
	** Playing with an XML file output:
		- $x = [xml] (cat .\output.xml)
		- $x
		- $x.gettype()
		- $x.play
		- $x.play.act
		- $x.play.act[0]
		- $x.play.act[0].scene
		- $x.play.act[0].scene[0].speech
		- $x.play.act.scene.speech
		- $x.play.act.scene.speech | Select -First 1
		- $x.play.act.scene.speech | group speaker | sort count
	** Where-Object.. [Can be used like this >> Get-Stuff | Where -Somestuff | sort | Out-file]
	** get-service | where {$_.status -eq "Running"} OR SAME WAY gives same result >>>>>> get-service | where {$PSItem.status -eq "Running"}
	** get-help *comparision* [Will list all the comparision operators.]
	** get-help *operator* [Will list all the operators.]
	** gps | where {$_.handles -ge 1000} OR SAME WAY gives same result >>>>>>>> gps | where handles -ge 1000

6. The PIPELINE : Deeper
	** Pipeline really works as follows:
		- By Value
		- By Property Name
		- What if property doesn't match - Customize it!!
		- The Parenthetical - When all else fails.
	** get-service | gm ["gm" - To see what kind of objects "get-service" cmdlet consists of which are possible to be sent through pipeline to another cmdlet. We can also see "Get-Service" is a ServiceController object.]
	** Not every Parameter accepts Pipeline. You can check that information with "get-help stop-service -full", where the "Accept pipeline input?" is TRUE. And also you can see -InputObject <ServiceController[]>, and "ServiceController" is the real element which allows a catch/ hook-up.
	** There are two ways of accepting pipeline input i) ByValue & ii) ByPropertyName.
	** You can sense by seeing "Get-Service" & "Stop-Service" has the "Service" matching which by name we can say might work with Pipeline with eachother like "Get-Service | Stop-Service".
	** Now you say would this work?? >>>>>> "Get-Service | Stop-Process", lets do "get-help stop-process -full" and see how many parameter Pipeline values are TRUE either by "Name" or "Value". You would find the parameter -InputObject <Process[]>, so you see here what this asks for; it's a "<Process[]>" object and hence there is no catch/ hook-up possible by "Value".
	** WAIT a MOMENT!! There is still a possibility by NAME parameter "-Name <String[]>", and if the same exact name parameter is available from sender object side through pipeline then there are possibilities that it can catch-up/ hook-up. Eg:- Get-Service | Stop-Process -WhatIf (It would only work when the name of a service matches with the name of Process.)
	** One more, but different example - "get-process calc | dir" [It's the PATH in common from both "PROCESS" and "DIR" objects hence it shows result.]
	** get-adcomputer -filter * | get-service -name bits [Should have listed all the bits service from all the AD Computers, but that won't happen in this case as it's unable to hook-up/ match -ComputerName parameter with parameters in "Get-Service".]
	** Get-Service -name bits | Select -Property name,status [As we know it displays just the name of the service and its status.]
	** Get-Service -name bits | Select -Property naem,stitus [This is the feature that here the two column names (i.e. Property Name) have got created with the name specified.
	   naem                  stitus
	   ----                  ------
	** Like the above example now we will try to change the property called "NAME" to "ComputerName" in  the "get-adcomputer" as follows with the help of HashTable syntax [Hence learn HashTable syntax]...
	** get-adcomputer -filter * | Select -Property name, @{name='ComputerName';expression={$_.name}} [Change the "NAME" in "get-adcomputer" to "ComputerName". This can create your own property as per your desire.]
	** Short version of the above cmnd => get-adcomputer -filter * | Select -Property name, @{n='ComputerName';e={$_.name}}
		
	
	To see what the receving cmdlet capable of receving 
	