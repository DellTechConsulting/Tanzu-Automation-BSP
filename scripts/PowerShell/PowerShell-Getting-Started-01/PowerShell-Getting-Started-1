POWERSHELL Basics: By Michael Bender

******************** Introduction to PS: ******************** 

=> Windows PowerShell: 
	>> Based on .NET Standard/ Framework.
	>> Windows only.
	>> PowerShell is integrated with Windows Server & Windows Admin Center which is linked with Azure]
=> PowerShell Core:
	>> Version 5 and above works on most of the platform, Windows, LINUX, MAC OS and many more.
	>> Based on .NET core.
	>> Open Source.
	>> Download from GitHub. [https://urldefense.com/v3/__https://github.com/PowerShell/PowerShell__;!!LpKI!lLVrPCCnSiBXNK79_wp68D0959aPD5pI3GThIK5qqVRN6iF0ZO3bknO03Qb1DNsiEyE2qMIRV1fFHm_mwcA1UlSTQqo$ [github[.]com]] >> Winx64 (Stable)
=> Using PS to report on STOPPED server services..
	>> Get-service [Lists all the Services.]
	>> Where-object
	>> Select-object

	   ++ get-service |
	   ++ >> where-object Status -eq 'Stopped' [Gets the list of all STOPPED services.]
	   
	   ++ get-service |
          >> Where-Object Status -eq 'Stopped' |
	      >> Select-Object Name,Status [Gets the list of all STOPPED services only with NAME and STATE]

	   ++ $data = get-service | Where-Object Status -eq 'Stopped' | Select-Object Name,Status [This stores the whole output in the variable named "$data".]
           ++ Now just type >> $data [Gets the list of all STOPPED services only with NAME and STATE]

 	   ++ $data | out-file .\services.csv [Gets the list of all STOPPED services only with NAME and STATE in a CSV output file.]
	   
	   ++ notepad .\services.csv [To view the output file in a notepad. It won't be in comma separated format.]

	   ++ $data | export-csv .\services2.csv [To export the output to another .csv file]

	   ++ get-content .\services2.csv | more [Now it shows the content in comma separated format in the screen it self, and | more displays one screen at a time.]

=> DEMO Environment setup..
	   ++ Domain "company.pri"
	   ++ One Windows 10 with PowerShell 7, RSA Tools & VSC
	   ++ One Windows 2019 with PowerShell 7, Active Directory & File/Print Services.
	   ++ One normal Windows 10 system.

       ++ Change the font size to 20.

	>> $PSVersionTable [To check the PS version.]
	>> (get-command).count [Displays the number of commands currently are available in windows PS.]
	   ++ Now downlaod RSAT x64 for Win-10 and install on one of the Win-10 machine, for all standalone tools to manage Win-Server.
           ++ After RSA Tools installation run (get-command).count to see the change in total number of commands.
           ++ Simply test another cmd >> get-command -Name *DHCP* [This will list all the DHCP related cmds available]


******************** PowerShell Basics: ******************** 

=> Command Basics:
	>> Verb-Noun [Do something-To something]
	>> Parameters
	   ++ Used to pass info. into PowerShell commands.
	   ++ All Parameters are called with a dash (-). After dash will need to provide value or string. Eg: - "-Computername" and "-File".
	>> Command to see what verbs are available.
	   ++ get-verb | more
	   ++ get-verb -Verb Set | format-list [To get more about the "Set" verb]
	   ++ get-verb -Group Security | Format-List [To list all of the "Verbs" included in Security group.]
	   ++ To read more about Verb got to MS Documentation by typing command >> start https://urldefense.com/v3/__https://aka.ms/psverbs__;!!LpKI!lLVrPCCnSiBXNK79_wp68D0959aPD5pI3GThIK5qqVRN6iF0ZO3bknO03Qb1DNsiEyE2qMIRV1fFHm_mwcA1N8ZJQRs$ [aka[.]ms]
	>> Parameters Cntd..
	   ++ get-service -Name M* -ComputerName Client01,DC01 [-Name & -ComputerName are two parameters] ["*" Is the wildcard.] [This command lists all the services starting from letter "M" from both the systems "Client01 & DC01"]
	>> ALIAS
	   ++ Get-Alias | More [Lists all the available aliases in PowerShell.] [Basically it's a shorten form of a cmd.]
	   ++ get-alias -Definition *service* [Lists all the alias related to Service.]
              Eg: - gsv -Name M* -ComputerName Client01,DC01 [Shortened command by shortening command.]
	>> Position of parameters:
	   ++ help gsv => It has 3 Syntax and the position of [-ComputerName <string[]>] is not the same. In some it's in the first and in other syntax it's in 2nd position. Hence one should use in such a way which makes your command shorter.
              Eg: - gsv -Name M* -Comp Client01,DC01 [Shortened command by shortening Parameter.]

=> 3 IMPORTANT Commands:
	>> i) Get-Command - Used to search installed commands.
	   ++ help Get-Command
       ++ help Get-Command -Example
	   ++ Get-Command | more
	   ++ Get-Command -Verb New [All the commands related to NEW.]
	   ++ Get-Command -CommandType Function | measure-object [Displays the count of number of Functions]
	   ++ Get-Command -Name *Ip* [Lists all the commands containing IP in it, but it's not the appropriate one to find all IP related commands, instead refer the bellow command.]
       ++ Get-Command -Name *Ip* -Module Net*
	   ++ Get-Command -Name *Ip* -Module NetTCPIP
	   ++ help Get-NetIPAddress -Examples
	   ++ Get-NetIPAddress
	   
	>> ii) Get-Help - Displays 'how-to' information for commands.
	   ++ Get-Help | more
	   ++ Get-Help *Service* | more [Lists all the Services related comands in Powershell]
	   ++ Help Get-service
	   ++ update-help [It will download all the latest help file from MS website.]
	   ++ help get-service -Example
	   ++ help get-service -full
	   ++ man get-service [man is a LINUX/ UNIX based command equvalent to HELP in PowerShell.]
	   ++ help *about* [Detailed documentation of how the backend of PowerShell works.]
	   ++ help Get-Command
	   
	
	
=> Documenting your work in the PowerShell console: -
	>> help Get-History
	   ++ md C:\Users\bhavanishankar_pradh\OneDrive - Dell Technologies\DELL-Project-Data\Scripts\PowerShell\transcripts [To create a new directory in order to save the work.]
       ++ Get-History [It lists all the commands that was executed in the PowerShell console.]
	   ++ invoke-history -id 24 [Will get the command with output for that particular -id provided]
	   ++ Get-History | Out-File 'C:\Users\bhavanishankar_pradh\OneDrive - Dell Technologies\DELL-Project-Data\Scripts\PowerShell\transcripts\history.txt'
       ++ notepad 'C:\Users\bhavanishankar_pradh\OneDrive - Dell Technologies\DELL-Project-Data\Scripts\PowerShell\transcripts\history.txt'
	   ++ Clear-History [Clears all the history of commands ran.]
	   
	>> help Start-Transcript [Help during debugging as it displays everything not just the history of commands but also with error msgs.]
	   ++ Start-Transcript -path 'C:\Users\bhavanishankar_pradh\OneDrive - Dell Technologies\DELL-Project-Data\Scripts\PowerShell\transcripts\transcript.txt' -append
	   ++ Get-Service | Where-Object -Property Status -eq Stopped [Eg. to just create some traffic for Transcript to capture the complete history]
	   ++ Stop-Transcript [To STOP the Transcript.]

=> Objects make PowerShell different: PS is Object Oriented
	>> Contains "Properties" and "Methods".
	                      Name (Property) DisplayName (Property) Status (Property)
	  Spooler (Object) =>
	  VSS     (Object) =>
	  WSUS    (Object) => 
    
	>> iii) Get-Member
	  ++ Gets properties and methods of objects.
	  ++ Used to see what makes up an object.
	  ++ Pipelining in Powershell [Get something | Sort something | Do something]
	     ** Eg:- get-service | Where-Object status -eq Stopped | start-service
	  ++ Get-Service | Get-Member [Gets properties and methods of objects.]
	  ++ Get-Service | Select-Object Name,MachineName,Status
	  ++ Get-Service | Select-Object Name,MachineName,Status | Get-Member
	  ++ Get-Service -ComputerName Client01,DC01 |
	     >> Where-Object status -eq "Stopped" |
		 >> Select-Object Name,MachineName,Status |
		 >> Sort-Object -Property MachineName | more
		 


******************** Gathering Information with PS: ******************** 

=> Troubleshooting Made Simple: 1)Identify the Issue >> 2) Find root cause >> 3) Determine and implement a solution >> 4) Verify results

=> Again here we will work with: 1) Get-Command 2) Get-Help or Help 3) Get-Member

=> Scenario-1: Can't connect to remote computer.
   >> get-command -Name *Fire* [Will list all Firewall related available commands.]
   >> get-command -Name get-*Fire* 	OR similary get-command -Name get-NetFire*[Will list all Get-Firewall related commands.]
   >> help Get-NetFirewallrule [To get the Syntaxs for Firewall of this specific command.]
   >> Get-NetFirewallrule | gm [Pipe the command to gm (Get-Member) to see what are the properties are available to work with.]
   >> Get-NetFirewallrule -Name *Remote* [Search a command with Name Remote as we want to run the command for a Remote m/c.]
   >> Get-NetFirewallrule -Name *RemoteDesktop* [Search a command with Name RemoteDesktop]
   >> Get-NetFirewallrule -Name *RemoteDesktop* | FT [Same above command to display the result in Table by piping it to FT (i.e. Format-Table.]
   >> Get-NetFirewallrule -Name *RemoteDesktop* | Set-NetFirewallrule -Enabled 'True' -Whatif [It will just check and not change the value from FALSE to TRUE.]

=> Tools to gather OS and H/W related Info.
   1. Windows Management Instrumentation (WMI) >> Get-WMIobject [Used to access the information content within Windows OS.]
   
   2. Common Information Model (CIM) >> Get-CimInstance [To work hand on hand with WMI, Can say WMI is Legacy and Cim is latest.]
   
   >> Get-Command *Counter* [To list all performance counter related commands.]
   >> Help Get-Counter [To see the Syntax.]
   >> Get-Counter [Lists counters like Network, Processor, Disk, Memory etc.]
   >> Get-Counter -ListSet *memory* [To list all of the counter sets for the Memory name in it.]
   >> Get-Counter -ListSet Memory [To list all of the conter related to Memory.]
   >> Get-Counter -ListSet Memory | Select -expand Counter [It expands all of the counters whose names were trunkated]
   >> Get-Counter -Counter "\Memory\Pages/sec","\Memory\% Committed Bytes In Use" | FT [Displays performance value for two counters specific to Memory.]
   >> Get-WmiObject -List * [Lists all of the WMI objects, all of the class names and classes to work with.] WMI is the Legacy version.
   >> Get-CimClass -ClassName * [Lists all of the Cim objects, all of the class names and classes to work with.] And Cim is the latest version as compared to WMI.
   >> Get-CimClass -ClassName *Memory*
   >> Get-WmiObject -class Win32_PhysicalMemory [It displays all the information about Physical memory of local system.]
   >> Get-CimClass -ClassName Win32_PhysicalMemory [Displays the same information as above command.]
   >> Get-CimClass -ClassName Win32_PhysicalMemory | Select Tag,Capacity [Want to see the Memory information in a compact view with just Tag & Capacity.]
   
   3. Gathering networking information.
   >> Get-Command get-NetIP* [Look for command to display IP Address]
   >> Get-NetIPAddress [Displays IP address for all of the N/W Adapters same like ipconfig command.]
   >> GCM get-*DNS* [Displays all the available DNS PS commands. GCM is short for Get-Command.]
   >> GCM get-DNSClient* [Displays all the available DNS Client PS commands.]
   >> Get-DnsClient [Displays the DNS Client information for the interfaces on my system.]
   >> Get-DnsClientCache [Displays DNS cache of the websites visted or accessed.]
   >> Get-DnsClientServerAddress [Displays what the DNS server is for all of my adapters.]
   >> Get-Command *SMB* [To search for mapping Network drive.]
   >> Get-Command *SmbMapping [To dive deeper and find drive mapping cmd.]
   >> Get-SmbMapping [To display all existing map drives.]
   >> Help New-SmbMapping -examples [Displays examples of how to create Map drive.]
   >> New-SmbMapping -localPath w: -remotepath \\DC01\Share ["w:" is the local drive letter assigned.]
   >> Get-SmbMapping
   >> cd w:\ & can dir .. etc etc
   
   4. Reviewing Event Log Information.
   >> get-command get-*Event* [Displays all the results which has Event word in the commands.]
   >> help Get-Eventlog -Examples [Displays all examples related to Get-Eventlog.]
   >> help Get-WinEvent -Examples [Actually Get-Eventlog is deprecated and instead there is Get-Winevent.]
   >> Get-Eventlog -LogName System | gm
   >> Get-Eventlog -log system -newest 1000 |
      >> where-object {$_.eventid -eq '1074'} |
	  >> format-table machinename,username,timegenerated -autosize
   
   5. Using Get-ComputerInfo.
   >> Help Get-ComputerInfo
   >> Help Get-ComputerInfo -Examples
   >> Get-ComputerInfo | More
   >> Get-ComputerInfo -Property *Memory*
   
   6. Working with files and folders in PowerShell.
   >> Help Get-ChildItem
   >> Get-ChildItem -Path w:\ -Recurse
   >> Get-ChildItem -Path w:\ -Recurse | GM [To check the properties available.]
   >> Get-ChildItem -Path w:\ -Recurse | where Extension -eq '.PNG' [Lists all the .png files in the path specified.]
   >> Get-ChildItem -Path w:\ -Recurse | where Extension -eq '.PNG' | ft Directory,Name,LastWriteTime
   >> Gcm *copy* [To find commands related to copy.]
   >> help Copy-Item -Examples
   >> Copy-Item w:\ -Destination c:\CopiedFolder -Recurse -Verbose
   >> dir c:\CopiedFolder -Recurse [To check whether all are copied.]
   >> move-item c:\CopiedFolder -Destination c:\MovedFolder -Verbose 
   >> dir MovedFolder
   >> Rename-Item c:\MovedFolder -NewName c:\RenamedFolder
   >> dir c:\   

******************** Remoting with PowerShell: ******************** 

=> Important Remoting tools: PS remoting is based on WS-Management 
   1. WMI
   2. Windows Remote Management (WinRM) => Is responsible to maintain connection between 2 systems. [By using WS-MAN (HTTP or HTTPS)]
   3. SSH
   4. RPC
 
=> Enable PowerShell Remoting on Windows machine:
   >> Enable-PSRemoting [Needs running on target Computer.]
   >> Set-PSSessionConfiguration

=> Enable PowerShell Remoting on in PowerShell Core:
   >> Install-PowerShellRemoting.ps1 [Needs Installing this script.]
   
=> Requirements for Remoting with PowerShell:
   >> Get-Service -ComputerName Client02 [You won't be able to execute PowerShell commands as Remoting is not enabled.]
   >> Enter-PSSession -ComputerName Client02
   >> Enable-PSRemoting -force [Run from client system to enable remoting.]
   >> Set-PSSessionConfiguration -Name Microsoft.PowerShell -ShowSecurityDescriptorUI [Here give RW&E access to HelpDesk-RemoteSupport Group]
   >> Get-NetfirewallRule | Where DisplayName -Like "*Windows Management Instrumentation*" | Set-NetFirewallrule -Enable True -Verbose [Enables Firewall rule.]
   >> Get-NetfirewallRule | Where DisplayName -eq "*Remote Service Management*" | Set-NetFirewallrule -Enable True -Verbose
   >> Get-Service -ComputerName Client02 [Now the commmand runs without any issues.]
   >> Enter-PSSession -ComputerName Client02 [Now the commmand runs without any issues.]
   
=> Working with Variables:
   >> Get-ChildItem ENV: | more [It shows all of the Environment variables that we can use.]
   >> $env:ComputerName [Quick way to see the system name you are on.]
   >> Get-Variable | More [Shows number of available variables in PowerShell that can be used.]
   >> $PSVersionTable [Is an example variable.]
   >> $ComputerName = "Client02" [Assigned "Client02" to the variable "ComputerName".]
   >> Write-Output "The name of the remote computer is $ComputerName" [Double quotes displays the value of the variable.]
   >> Write-Output 'The name of the remote computer is $ComputerName' [Single quote doesn't displays the value of the variable.]
   >> $Credential = Get-Credential [To securely store the password.]
   >> $Credential = Get-Credential [Same credential when ran on PowerShell Core, won't display a GUI to enter credential.]
   >> Get-Variable -Name C* [Displays the variables starting with letter "C".]
   >> Get-Service -ComputerName $computername
   
   ** Remote using "PSSession"
   >> $ComputerName = "Client02"
   >> Get-Service -Computername $Computername | Select Name,Status
   >> gcm *PSSession [To find commands which has PSSession noun in it.]
   >> $Credential = Get-Credential
   >> New-PSSession -ComputerName $ComputerName -Credential $Credential [It will create a session with computer supplied to $CompyterName variable.]
   >> Enter-PSSession -Name WinRM1 [To connect into that remote m/c after the above cmd we will need to run this cmd.]
   >> $env:ComputerName
   >> Exit [To Exit and go back to local machine.]
   >> Get-PSSession [Lists all the established session currently.]
   >> Enter-PSSession -id 1 [This way by supplying the session ID too one can connect to the remote system.]
   >> Exit
   >> Remove-PSSession [To remove the established session.]
   >> Id [0]: 1
   >> Get-PSSession [Won't list any session as it was removed.]
   
   ** Remote using "Invoke-Command"
   >> Help Invoke-Command
   >> $ComputerName = "Client02"
   >> $Credential = Get-Credential
   >> Invoke-Command -ComputerName $ComputerName -Credential $Credential -ScriptBlock { Get-Service -ComputerName $ComputerName } [This will give an error as the variable defined locally for "-ComputerName $ComputerName" is not able to take it to remote, hence small modification required.]
   >> Invoke-Command -ComputerName $ComputerName -Credential $Credential -ScriptBlock { Get-Service -ComputerName $ComputerName $using:ComputerName} [$using:ComputerName helps fetch variable from local system, and will pass it to script block.]
   >> $data = Invoke-Command -ComputerName $ComputerName -Credential $Credential -ScriptBlock { Get-Service -ComputerName $ComputerName $using:ComputerName} [Puts the value into variable "$data"]
   >> $data | gm [It passes back to us the object and it shows the property in there.]
   >> Invoke-Command -ComputerName DC01 -cred (Get-Credential) -ScriptBlock { Get-Aduser -Identity felixb | format-list }[Example command to run from PS-7. It signifies that without even having local Active Directory tools and cmds we can still fetch the AD details.]
   
   ** Remote using "New-CimSession"
   >> $ComputerName = "Client02"
   >> $Credential = Get-Credential
   >> Help New-CimSession
   >> $cimsession = New-CimSession -ComputerName $ComputerName -Credential $Credential
   >> $cimsession [Display's all establised cim sessions.]
   >> Get-CimSession [Also display's all establised cim sessions.]
   >> Help Get-DNSClientServerAddress
   >> Get-DNSClientServerAddress -CimSession $cimsession [It displays all the of the DNS Client/ Server address information on Remote system.]   
   
   
******************** Building a User Inventory Script with PowerShell: ********************

   >> PowerShell Script : 
      ++ Are just bunch of cmds from the CLI & is saved in .PS1 format.
	  ++ It's not programming, instead learn .Net or C# for Application development.
	  
   >> Running Scripts in PowerShell :
      ++ Get-ExecutionPolicy [Shows status as Restricted initially. Other Status: Restricted, AllSigned, RemoteSigned, Unrestricted, Bypass & Undefined]
	  ++ Help Set-ExecutionPolicy -Parameter ExecutionPolicy
	  ++ Set-ExecutionPolicy -ExecutionPolicy RemoteSigned [It allows all scripts to be RUN.]
	  
   >> Using PowerShell ISE :
      ++ 1) Terminal Window 2) Commands Window 3) Scripting Pane
	  ++ RUN Selectin option allows only those selected sections.
	
   >> Using Visual Studio Code :
      ++ Download Visual Studio Code [https://code.visualstudio.com/download [User Installer x64 version]
	  ++ It's a Multi-Platform tool for editing code.
	  ++ Go to "Extensions" in the download website to bring additional features.
	  ++ Open VSC >> Left Top "Extension: Marketplace" type "PowerShell" & INSTALL. >> You can see on left a PowerShell ICON got added.
	
   >> Building a Parameterized Script :
      ++ Script Basics :-
	     -> Variables
		 -> Parameters
		 -> Logic
		 -> Member Enumeration
		 
	  ++ Working with script basics.
	     ** .\get-servicestatus.ps1 -Computername DC01
		 ** Remark lines starts with #
		 ** To make it a Parameterized script we need to add Parameter bock as follows..
		    
			#Get-ServiceStatus.ps1 - Script displays the status of services running on a specified machine.
			#Create a mandatory parameter for Computername and for Service Status.
			Param (
			     [Parameter(Mandatory=$true)]
				 [string[]]                       #Additional [] after string denotes this parameter accepts multiple inputs 
				  $ComputerName                   #Note this is the same name as the variable used in your code below.
		    )
			
			#Creates a variable for Get-Service Objects
			#As it can hold multiple objects, referred to as an array
			$Services = Get-Service -ComputerName $Computername
			
			#Use foreach construct to perform actions on each object in $Services 
			Foreach ($Service in $Services) {
			
			     #Create variable containing status and displayname using member enumeration
				 $ServiceStatus = $service.status        #Decimal notating the variable allows access to properties of each object.
				 $ServiceDisplayName = $Service.displayname
				 
				 #Use if-else construct for decision making
				 
				if ($ServiceStatus -eq 'Running') {
				    Write-Output "Service OK - Status of $ServiceDisplayName is $ServiceStatus"
			    }
				Else {
				    Write-Output "Check Service - Status of $ServiceDisplayName is $ServiceStatus"
				}
			}
			
				
		 ++ Walking through Parameterized Script Steps:
            1)
            #Get-ServiceExamplept1.ps1
			#Step-1 Run HardCoded command.
            get-service -ComputerName DC01
                        Where-Object -Property Status -eq 'Stopped'

			2)
			#Get-ServiceExamplept2.ps1
            #Step-2	Add variables
            get-service -ComputerName $CompyterName |
                        Where-Object -Property Status -eq 'Stopped'

            3)
            #Get-ServiceExamplept3.ps1	
            #Step-3 Parameterized Variable
            #Parameter Help description
            Param (
			     [Parameter(Mandatory=$true)]
				 [string[]]                       #Additional [] after string denotes this parameter accepts multiple inputs 
				  $ComputerName                   #Note this is the same name as the variable used in your code below.
		    )			
	        #Enter Script Block here
			get-service -ComputerName $CompyterName |
                        Where-Object -Property Status -eq 'Stopped'
			
             
			4)
			#Get-ServiceExamplept4.ps1	
			#Step-4 Add Logic
			Param (
			     [Parameter(Mandatory=$true)][string[]]$ComputerName
				 
		    #Loop through each computer in computername parameter, and perform actions in code block.
			foreach ($target in $computername) {
			#Enter code block here and change variable to match foreach condition
			      get-service -ComputerName $ComputerName |
                  Where-Object -Property Status -eq 'Stopped'			
			}
						
	    NOTE: All the above commands gives te same output but in different ways.
		
=> Information to gather in script:
   1. Operating System Information
   2. Disk Free Space
   3. Amount of System Memory
   4. Last Reboot of System
   5. IP Address & DNS name
   6. Write Output to Screen
   
=> Building a remote information gathering script
   - Determine Script Tasks
   - Building Comments
   - Adding commands to script
   - Creating variables and parameters
   - Running against remote systems
   
=> 1) #ScriptsTasks.ps1
      # OS Description
	  
	  
	  #Disk freespace on OS Drive
	  
	  
	  #Amount of System Memory
	  
	  
	  #Last Reboot of System
	  
	  
	  #IP Address & DNS name
	  
	  
	  #DNS Server of Target
	  
	  
	  #Write Output to Screen
	
	2) #ScriptCommands.ps1  
	

    3) #Get-Memory.ps1
	

    4) BaseTemplate.ps1
	

    5) get-helpdesksupportdata.ps1
	

******************** Next Steps with PowerShell: ********************

=> Resources : 

    1. docs.microsoft.com
       - https://aka.ms/psdocs
	2. PowerShell.org
	   - Ask questions and join the commnity.
	3. Pluralsight
	   - htpps://www.pluralsight.com/paths/windows-powershell-essentials
	4. From PS Console:
	   - Type>>> Help get-service -Online
	5. Next Course option:
	   - Putting PoweShell to Work by Jeff Hicks
	   - Automation with PowerShell Scripts by Jeff Hicks
	   - For Windows Admins: Windows Server Administration Fundamentals using PowerShell by Michael Bender
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
   Â)i