Automation with PowerShell Scripts: By Jeff Hicks

******************** Resources ******************** 
=> List of Resources:
   - PowerShell.org
   - Pluralsight.com
   - http://bit.ly/PSHEssentials

=> Scripting:
   >> get-content sample.ps1 [Displays all the content of the PS.1 file in the PS Console screen.]
   >> .\sample.ps1 | Format-Table -AutoSize
   >> Invoke-Item . [This opens the Directory path from where you have run this command.] [You might see the security msg in the ps1 file by right-clicking it. Which means the file is downloaded or have coe from Internet]
   >> unblock-file c:\scripts\downloaded.ps1 [Cmd to Unblock the file from such security.]
   >> PowerShell Scope:
      - Global [Means the value for a variable defined in Global scope i.e. $x=50 you ran on the PS Console.
	  - Script [Means the value for a variable defined only within a script and doesn't change the Global value of a variable.]
	  DOUBTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
   >> Multi-line to comment, you can use <# xxxxxxxxxxxxxyyyyyyyyyyyyyzzzzzzzzzzzzzzzz #>
   >> code .\xxxxx.ps1 [This will open the code in Visual Studio Code.]
   >> Parameterize to avoid hard-coding.

=> If-statements:
   >> If-statement:
      ++ If (<some condition is true>) {
           <do something>
	     }
   >> If Else:   
	  ++ If (<some condition is true>) {
           <do something>
	     }
		 Else
		 {
		   <do something else if it isn't true>
		 }
	>> ElseIf:	 
	   ++ If (<some condition is true>) {
           <do something>
	      }
		 ElseIf (<some other condition is true>) {
		   <do something else if this is true>
		 Else
		  {
		   <do something else if it isn't true>
		  }
		 }
	>> Examples: -
	   ++  If (test-path c:\files\data.txt) {
           $data = Get-Content c:\files\data.txt
	     }
		 Else
		 {
		   Write-Warning "Can't find c:\files\data.txt"
		 }
		
		++ $age = 42
		   if ($age -ge 55) {
		       $catagory = "alpha"
			}
		   elseif ($age -ge 40) {
		       $catagory = "bravo"
		    }
		   elseif ($age -ge 25) {
		       $catagory = "gamma"
		    }
		   else {
		       $catagory = "omega"
			}

    >> Enumeration: -
       ++ ForEach-Object & ForEach, it's based on the context you can use these.
	   ++ Example: 2,5,6,8,9 | ForEach { $_ * 3 } [$_ represents current object in the pipeline.] [ForEach-Object example where alias "ForEach" is used]
	   ++ Example: Get-Content computers.txt | Foreach-Object {
	               Get-Smbshare -CimSession $_ | Where { -Not $_.special }
				   } | Select PSComputername,Name,Path,Description                [ForEach-Object example]
	   ++ Example: $n = 1,23,..10
	               foreach ($item in $n) {
				      $file = "TestFile-$item.txt"
					  New-Item $file
				   }                                                              [ForEach example - This doesn't pass objects down the pipeline, example after end of currly bracket pipeline can't be used.]

    >> ARRAYS: -
       ++ $arr = @()
       ++ Items are referenced by Index number.
          - 0 based Index
          - -1 to start at the end
       ++ $n = 1..5         #The variable N is an array of numbers. ["1..5" means defining array of 5 values/ items in array.]
          $n.count	        #Count the number of elements in the array.
       ++ $n                #PowerShell unrolls the array, that means displays the value from 1 To 5 virtically.
       ++ $n[1]	            #Access an item by index number.
	   ++ $s = Get-Service  #Create an error of services.
	   ++ $s[-1].Name       #You can also use an index number starting at the end.
	   
	   ++ $arr = @()        #Create an empty array.
	   ++ $arr += 100       #Add an item to the array.
	                        #You can't remove individual items.
	   ++ $b = "jeff", "jason", "don", "tim", "adam"  #Comma separated items are treated as an array.
	   ++ $b -is [array]    #Test if something is an array.
	  
	>> Hashtable: - Similar to Array
	   ++ Collection of key/value pairs.
	   ++ AKA Dictionary object
	   ++ $hash=@{Name="jeff"} [It means => @{Key = Value}
	   ++ $hash=@{Name="jeff"; Color="green"; Version=$PSVersionTable.PSVersion} [For multiple entries separate it with semicolumn or HIT ENTER after every Name-Value key for new line.]
	   ++ $hash [It will show all the Key=Value results.]
       ++ $hash.Add("foo",1)  [We can easily modify the Hash Table, Eg.-1]
       ++ $hash.color = "red" [We can easily modify the Hash Table, Eg.-2]
	   ++ $h = [ordered]@{    [For ordered Hashtable. This will display the result in order as per the entered data sequence.]
	        Name = 'Jeff'
			Color = 'Green'
			Version = $PSVersionTable.psversion
		  }
	   ++ SPLATTING [Defining a hastable of parameter names and values.]
	   ++ $params = @{
	        Computername = 'Server01'
			Classname = 'win32_logicaldisk'
			Filter = "deviceid='C:'"
			Verbose = $True
		  }
		  Get-CimInstance @params [Use the @ symbol to reference the hash table.]
    
    >> Objects in the Pipeline: -
       ++ Select-Object        DOUBTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
       ++ New-Object           DOUBTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
       ++ [pscustomobject]     DOUBTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
       ++ Try/ Catch           DOUBTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
	   
    >> #Get DISK usage information and export it to a CSV file for trend reporting
		Param(
			[string[]]$Computername = $env:COMPUTERNAME
		)
		
	   #Path to CSV file is hard coded in this case.
	    $csv = "c:\script\diskhistory.csv"
		
	   #Initialize an empty array.
	    $data = @()
		
	   #Define a hashtable of parameters to splat to Get-CimInstance.
	    $CimParams = @{
			Classname   = "Win32_LogicalDisk"
			Filter      = "drivetype = 3"
			ErrorAction = "Stop"
		}
		
		Write-Host "Getting disk information from $Computername" - ForegroundColor Cyan
		foreach ($computer in $computername) {
			Write-Host "Getting disk information from $computer." - ForegroundColor Cyan
			#Update the Hashtable on the fly.
			$CimParams.Computername = $CimParams
			Try {
				$disks = Get-CimInstance @cimparams
			
				$data += $disks | 
					Select-Object @{Name = "Computername"; Expression = {$_.SystemName}},
				DeviceID, Size, Freespace,
				@{Name = "PctFree"; Expression = { ($_.Freespace / $_.Size) * 100}},
				@{Name = "Date"; Expression = {Get-Date}}
			} #try
			Catch {
				Write-Warning "Failed to get DISK data from $($computer.toUpper()). $($_.Exception.message)"
			} #catch
		} #foreach
		
		#Only export if there is something in $data
		if ($data) {
			$data | Export-Csv -Path $csv -Append -NoTypeInformation
			Write-Host "Disk report complete. See $CSV." -ForegroundColor Green
		}
		else {
			Write-Host "No disk data found." -ForegroundColor Yellow
		}
		
		#Sample usage
		# .\GetDiskHistory.ps1 -Computername DC01,XYZ,Srv1,Srv2
		
=> Scripting Techniques: - DOUBTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT
			
=> PowerShell Fun: - 
	>> By leveraging some .Net tricks into PowerShell scripts.
		++ Working with strings
			** $s = "powershell rocks!"
			** $s | Get-Member | more [To see what can we do more with STRINGS.]
			** $s.Length [One of the property "Length" as an example, which shows the length of the whole string.]
			** $s.ToUpper() [One of the method as an example, which gets all the character to CAPITAL letters.]
			** $s | get-member substring [To see how we can use "substring"]
			** $s.substring.OverloadDefinitions ["OverloadDefinitions" property shows all the possible ways we can use the substring]
			** $s.Substring(5) [This will display the string from 6th character onwards. (shell rocks!)]
			** $s.Substring(1,4) [This will display the string from 2nd to 5th index characters.]
			** $s.IndexOf("s") [Displays what is the index number of character "s" in the string.]
			** $s.LastIndexOf("s") [Displays what is the index number of character last "s" in the string.]
			** $s.Replace("e","3") [Replaces all "e" with "3". It's case-sensitive so lower case will only replace small letters.]
			** $name = $s.Replace("p","P").Replace("s","S") [Multiple character replacements can be done like this.]
			** $t = 'a,b,c,d,e,f,g' [Assigned strings to variable.]
			** $t [Displays the string in horizontal format as it's not ARRAY.]
			** $t -is [array] [To check the variable is an ARRAY or not.]
			** $split = $t.Split(",") [To convert the plain STRING to an ARRAY.]
			** $Split [WIll display the output in toe ARRAY format.]
			** $Split -is [array] [It will display TRUE.]
			
			** $alpha = 'a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z' [Variable with comma separated strings]
			** $num = 0..9 [This is set to be an Array.]
			** $char = '!,),@,(,/,*,$,&,^,%,[,],>,<' [Variable with comma separated special character strings]
			** $arr = @() [Initialised an empty Array.]
			** $arr+= $alpha.split(',') | [Split the strings into array and pick 5 random characters for the Array.]
			** $arr[0] = $arr[0].toupper() [Changing the first item to Uppercase.]
			** $arr[-1] = $arr[-1].toupper() [Changing the last item to Uppercase.]
			** $arr += $num | Get-Random -count 2[To add some number to the Array]
			** $arr += $char.split(',') | Get-Random -count 3 [Split the strings into array and pick 3 random special characters for the Array.]
			** ($arr | Get-Random -Count $arr.count) -join "" [It's to join all the jumble up characters and would help in generate password by taking characters from various variable/ strings.]
			
		++ Working with dates
			** $now = Get-Date
			** $now | get-member | more [To check what possible Properties and Methods we have for Date.]
			** $now | select * [To select everything of property and display for the Date Time object.]
			** $now.DayofWeek [Using DayofWeek property to display the Day of the Week.]
			** $now.ToShortDateString()
			** $now.ToShortTimeString()
			** $now.ToUniversalTime()
			** Get-Date -Format ddMMyyyy [We can also create some custome formating of Date.]
			** Get-Date -Format ddMMyyyy_hhmmss
			** $now.AddDays(42) [What is the date 42 days from now.]
			** $now.AddHours(500) [What is the time after 500 Hrs from now.]
			** $now.AddDays(-60) [What was the date 60 days ago.]
			** dir \\srv1\pubic -File
			** $cutoff = (Get-Date).AddDay(-180).Date [To find the files from a share path that are modified 180 days ago.]
			** dir \\srv1\pubic -File | Where {$_.LastWriteTime -le $cutoff }
		++ Doing Math
			** [math] [It's math class, consists of static methods or properties to perform Mathematical operations.]
			** [math].GetMembers() | Select Name,MemberType -unique | sort MemberType,Name | more
			** [math]::PI [To invoke the list of Methods, here "PI"]
			** [math]::E [To invoke the list of Methods, here "PI"]
			** [math]::pow.OverloadDefinitions [Here "OverloadDefinitions" shows how to use "pow" method.]
			** [math]::Pow(3,2)
			** [math]::Sqrt(144)
			** $n = 1345244.8894
			** [math]::Truncate($n) [To truncate and number by removing digits after decimal.]
			** [math]::Round($n,2) [To roundoff to two decimal value.]
			** $n -as [int] [To treat this number as integer.]
			
			** dir $env:temp -file - Recurse | Measure-Object Length -sum |
			  >Select Count,@{Name="SumMB";Expression = {[math]::round($_.sum/1mb,3)}}
			
			** Get-CimInstance win32_operatingsystem | Select *memory* [Displays all the Memory properties.]
			** Get-CimInstance win32_OperatingSystem -Computername $env:computername |
			  >Select PSComputername,@{Name="TotalMemGB";Expression={$_.totalvisiblememorysize/1MB -as [int]}},
			  >@{Name="FreeMemGB";Expression={ [math]::Round(($_.freephysicalmemory/1Mb),4}},
			  >@{Name="PctFreeMem";Expression = {[math]::Round(($_.freephysicalmemory/$_.totalvisiblememorysize)*100,2)}}
			  
=> Walkthrough: Creating a Controller Script
		>> Controller Script - A PowerShell script that orchestrates or runs other PowerShell commands, Functions and Scripts.
			
			** Get-Volume -DriveLetter C -CimSession $env:computername |
			   Select-Object PSComputername,DriveLetter,Size,SizeRemaining,
			   @{Name="PctFree";Expression={($_.SizeRemaining/$_.size)*100}}
	   
	   
			   
=> Jeff Hicks Blog: https://jdhitsolutions.com/blog			
=> Go through about topics
	** About_scripts
	** About_scriptinghelp
	** About_scripting_best_practices
	** About_do
	** About_while
	** About_for
	** About_switch
	** About_*operators
=> Learn more PowerShell scripting:
	** Create PowerShell functions
	** Create functions into modules
	** Create graphical PowerShell tools with WPF
	** Leverage PowerShell scripting skills to other areas like DSC[Desired State Configuration].
	
=> Continue Pluralsight:
	** Watch - Play by Play: PS from IDEA to ACTION
	** Watch - Building Advanced PS Functions & Modules
	** PowerShell toolmaking Fundamentals

=> PowerShell Resources:
	** PowerShell.org
	** PowerShell user group - https://bit.ly/PSUserGroups
	** Conferences/ Events: 
		- Techmentor
		- PowerShell+DevOps Global Summit
		- PowerShell Saturday
	** Social Media:
		- Twitter: #PowerShell & #PSTweetChat
		 